using PactNet.Verifier;
using ProductService.ContractTests.Infrastructure;

namespace ProductService.ContractTests.Http;

/// <summary>
///     Provider-side HTTP Pact verification.
///     ProductService is the HTTP PROVIDER — it serves the REST API.
///     OrderService is the HTTP CONSUMER — it calls the API.
///     Boots ProductService on a real Kestrel port via WebApplicationFactory,
///     reads the pact file generated by OrderService.ContractTests, replays
///     every HTTP interaction against the real running API, and fails if any
///     response does not satisfy the consumer's expectations.
///     Run AFTER OrderService.ContractTests to ensure the pact file exists
/// </summary>
[TestFixture]
public class ProductServiceHttpProviderTests
{
    [OneTimeSetUp]
    public void OneTimeSetUp()
    {
        _factory = new ProductServiceWebApplicationFactory();
        _factory.StartServer();
        _factory.CreateClient();
    }

    [OneTimeTearDown]
    public async Task OneTimeTearDown() => await _factory.DisposeAsync();

    private ProductServiceWebApplicationFactory _factory = null!;

    [Test]
    public void GetProduct_AsProvider_SatisfiesOrderServiceContract()
    {
        var pactFile = Path.Combine(PactConfigFactory.PactDir, "OrderService-ProductService.json");

        Assert.That(File.Exists(pactFile), Is.True,
            $"Pact file not found at {pactFile}. " +
            "Run OrderService.ContractTests first to generate the pact file.");

        using var verifier = new PactVerifier("ProductService", PactConfigFactory.VerifierConfig());

        verifier
            .WithHttpEndpoint(_factory.ServerUri)
            .WithFileSource(new FileInfo(pactFile))
            .WithProviderStateUrl(_factory.ProviderStatesUri)
            .Verify();
    }
}
